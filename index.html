<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Richie">
<meta property="og:url" content="https://blog.msrily.com/index.html">
<meta property="og:site_name" content="Richie">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Richie">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.msrily.com/"/>





  <title>Richie</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Richie</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.msrily.com/2018/06/19/blog15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Richie Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Richie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/19/blog15/" itemprop="url">iOS Runloop</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-19T14:34:20+08:00">
                2018-06-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h3><p>实际上是一个对象，这个对象管理了其需要处理的事件和消息.</p>
<p>macOS/iOS系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。</p>
<p>CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的(<strong>CFSpinlock/</strong>CFSpinUnlock)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;			/* locked for accessing mode list */</span><br><span class="line">    __CFPort _wakeUpPort;			// used for CFRunLoopWakeUp </span><br><span class="line">    Boolean _unused;</span><br><span class="line">    volatile _per_run_data *_perRunData;              // reset for runs of the run loop</span><br><span class="line">    pthread_t _pthread;</span><br><span class="line">    uint32_t _winthread;</span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line">    CFMutableSetRef _commonModeItems;</span><br><span class="line">    CFRunLoopModeRef _currentMode;</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line">    struct _block_item *_blocks_head;</span><br><span class="line">    struct _block_item *_blocks_tail;</span><br><span class="line">    CFTypeRef _counterpart;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct __CFRunLoop * CFRunLoopRef;</span><br></pre></td></tr></table></figure>
<p>NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p>
<p>CFRunLoopRef 的代码是开源的，你可以在<a href="http://opensource.apple.com/tarballs/CF" target="_blank" rel="noopener">这里</a> 下载到整个 CoreFoundation 的源码来查看。</p>
<h3 id="RunLoop与线程的关系"><a href="#RunLoop与线程的关系" class="headerlink" title="RunLoop与线程的关系"></a>RunLoop与线程的关系</h3><p>CFRunLoop 是基于 pthread 来管理的，苹果不允许直接创建RunLoop，可以通过CFRunLoopGetMain()和CFRunLoopGetCurrent()获取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef CFRunLoopGetMain(void) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    static CFRunLoopRef __main = NULL; // no retain needed</span><br><span class="line">    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed</span><br><span class="line">    return __main;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CFRunLoopRef CFRunLoopGetCurrent(void) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">    if (rl) return rl;</span><br><span class="line">    return _CFRunLoopGet0(pthread_self());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">    if (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">	t = pthread_main_thread_np();</span><br><span class="line">    &#125;</span><br><span class="line">    __CFSpinLock(&amp;loopsLock);</span><br><span class="line">    if (!__CFRunLoops) &#123;</span><br><span class="line">        __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">	CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">	CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line">	CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br><span class="line">	if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123;</span><br><span class="line">	    CFRelease(dict);</span><br><span class="line">	&#125;</span><br><span class="line">	CFRelease(mainLoop);</span><br><span class="line">        __CFSpinLock(&amp;loopsLock);</span><br><span class="line">    &#125;</span><br><span class="line">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">    __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">    if (!loop) &#123;</span><br><span class="line">	CFRunLoopRef newLoop = __CFRunLoopCreate(t);</span><br><span class="line">        __CFSpinLock(&amp;loopsLock);</span><br><span class="line">	loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">	if (!loop) &#123;</span><br><span class="line">	    CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">	    loop = newLoop;</span><br><span class="line">	&#125;</span><br><span class="line">        // don&apos;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span><br><span class="line">        __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">	CFRelease(newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    if (pthread_equal(t, pthread_self())) &#123;</span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);</span><br><span class="line">        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以通过pthread_main_thread_np()或[NSThread mainThread]来获取主线程；也可以通过 pthread_self()或[NSThread currentThread]来获取当前线程。</p>
<p>线程和RunLoop之间是一一对应的，其关系是保存在一个全局的Dictionary(pthread_t : CFRunLoopRef)里的同时，也在线程里保存了一份<br>_pthread_setspecific_direct(CF_TSD_KEY, arg) 可通过本线各的<br>_CFGetTSD(<strong>CFTSDKeyRunLoop) // </strong>CFTSDKeyRunLoop 10<br>获取已保存的RunLoop。</p>
<p>线程刚创建时并没有RunLoop，如果你不主动获取，那它一直都不会有。RunLoop的创建是发生在第一次获取时，RunLoop的销毁是发生在线程结束时。你只能在一个线程的内部获取其RunLoop（主线程除外）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct __CFRunLoopSource * CFRunLoopSourceRef;</span><br><span class="line"></span><br><span class="line">typedef struct __CFRunLoopObserver * CFRunLoopObserverRef;</span><br><span class="line"></span><br><span class="line">typedef struct __CFRunLoopTimer * CFRunLoopTimerRef;</span><br><span class="line"></span><br><span class="line">typedef struct __CFRunLoopMode *CFRunLoopModeRef;</span><br></pre></td></tr></table></figure>
<h3 id="CFRunLoopSourceRef"><a href="#CFRunLoopSourceRef" class="headerlink" title="CFRunLoopSourceRef"></a>CFRunLoopSourceRef</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopSource &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    uint32_t _bits;</span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    CFIndex _order;			/* immutable */</span><br><span class="line">    CFMutableBagRef _runLoops;</span><br><span class="line">    union &#123;</span><br><span class="line">	CFRunLoopSourceContext version0;	/* immutable, except invalidation */</span><br><span class="line">        CFRunLoopSourceContext1 version1;	/* immutable, except invalidation */</span><br><span class="line">    &#125; _context;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Source有两个版本：Source0 和 Source1。</p>
<ul>
<li>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</li>
<li>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。</li>
</ul>
<h3 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopObserver &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    CFRunLoopRef _runLoop;</span><br><span class="line">    CFIndex _rlCount;</span><br><span class="line">    CFOptionFlags _activities;		/* immutable */</span><br><span class="line">    CFIndex _order;			/* immutable */</span><br><span class="line">    CFRunLoopObserverCallBack _callout;	/* immutable */</span><br><span class="line">    CFRunLoopObserverContext _context;	/* immutable, except invalidation */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop</span><br><span class="line">    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。</p>
<p>Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p>
<h3 id="CFRunLoopTimerRef"><a href="#CFRunLoopTimerRef" class="headerlink" title="CFRunLoopTimerRef"></a>CFRunLoopTimerRef</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopTimer &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    uint16_t _bits;</span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    CFRunLoopRef _runLoop;</span><br><span class="line">    CFMutableSetRef _rlModes;</span><br><span class="line">    CFAbsoluteTime _nextFireDate;</span><br><span class="line">    CFTimeInterval _interval;		/* immutable */</span><br><span class="line">    CFTimeInterval _tolerance;          /* mutable */</span><br><span class="line">    uint64_t _fireTSR;			/* TSR units */</span><br><span class="line">    CFIndex _order;			/* immutable */</span><br><span class="line">    CFRunLoopTimerCallBack _callout;	/* immutable */</span><br><span class="line">    CFRunLoopTimerContext _context;	/* immutable, except invalidation */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">truct __CFRunLoopMode &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;	/* must have the run loop locked before locking this */</span><br><span class="line">    CFStringRef _name;</span><br><span class="line">    Boolean _stopped;</span><br><span class="line">    char _padding[3];</span><br><span class="line">    CFMutableSetRef _sources0;</span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line">    CFMutableDictionaryRef _portToV1SourceMap;</span><br><span class="line">    __CFPortSet _portSet;</span><br><span class="line">    CFIndex _observerMask;</span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">    dispatch_source_t _timerSource;</span><br><span class="line">    dispatch_queue_t _queue;</span><br><span class="line">    Boolean _timerFired; // set to true by the source when a timer has fired</span><br><span class="line">    Boolean _dispatchTimerArmed;</span><br><span class="line">#endif</span><br><span class="line">#if USE_MK_TIMER_TOO</span><br><span class="line">    mach_port_t _timerPort;</span><br><span class="line">    Boolean _mkTimerArmed;</span><br><span class="line">#endif</span><br><span class="line">#if DEPLOYMENT_TARGET_WINDOWS</span><br><span class="line">    DWORD _msgQMask;</span><br><span class="line">    void (*_msgPump)(void);</span><br><span class="line">#endif</span><br><span class="line">    uint64_t _timerSoftDeadline; /* TSR */</span><br><span class="line">    uint64_t _timerHardDeadline; /* TSR */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>苹果提供的 Mode 有五个，其中两个是公开的：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 kCFRunLoopCommonModes (NSRunLoopCommonModes)</p>
<p><img src="/images/5b0d42bc-aaea-4359-a0d5-fcc27beeb206.png" alt=""></p>
<h3 id="RunLoop-的内部逻辑"><a href="#RunLoop-的内部逻辑" class="headerlink" title="RunLoop 的内部逻辑"></a>RunLoop 的内部逻辑</h3><p><img src="/images/93922e2b-0e5a-4610-8b81-42c2573d5bd9.png" alt=""></p>
<p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br></pre></td><td class="code"><pre><span class="line">void CFRunLoopRun(void) &#123;	/* DOES CALLOUT */</span><br><span class="line">    int32_t result;</span><br><span class="line">    do &#123;</span><br><span class="line">        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">    &#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SInt32 CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123;     /* DOES CALLOUT */</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123;     /* DOES CALLOUT */</span><br><span class="line"></span><br><span class="line">    /* RunLoop 正在被移除 */</span><br><span class="line"></span><br><span class="line">    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false);</span><br><span class="line">    if (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;</span><br><span class="line">	Boolean did = false;</span><br><span class="line">	if (currentMode) __CFRunLoopModeUnlock(currentMode);</span><br><span class="line">	__CFRunLoopUnlock(rl);</span><br><span class="line">	return did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    /* 通知 Observers: RunLoop 进入 loop */</span><br><span class="line"></span><br><span class="line">	if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">	result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line"></span><br><span class="line">    /* 通知 Observers: RunLoop 离开 loop */</span><br><span class="line"></span><br><span class="line">	if (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">    ...</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    uint64_t startTSR = mach_absolute_time();</span><br><span class="line"></span><br><span class="line">    if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">        __CFRunLoopUnsetStopped(rl);</span><br><span class="line">	return kCFRunLoopRunStopped;</span><br><span class="line">    &#125; else if (rlm-&gt;_stopped) &#123;</span><br><span class="line">	rlm-&gt;_stopped = false;</span><br><span class="line">	return kCFRunLoopRunStopped;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mach_port_name_t dispatchPort = MACH_PORT_NULL;</span><br><span class="line">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</span><br><span class="line">    if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();</span><br><span class="line">    </span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">    mach_port_name_t modeQueuePort = MACH_PORT_NULL;</span><br><span class="line">    if (rlm-&gt;_queue) &#123;</span><br><span class="line">        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</span><br><span class="line">        if (!modeQueuePort) &#123;</span><br><span class="line">            CRASH(&quot;Unable to get port for run loop mode queue (%d)&quot;, -1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    dispatch_source_t timeout_timer = NULL;</span><br><span class="line">    struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context));</span><br><span class="line">    if (seconds &lt;= 0.0) &#123; // instant timeout</span><br><span class="line">        seconds = 0.0;</span><br><span class="line">        timeout_context-&gt;termTSR = 0ULL;</span><br><span class="line">    &#125; else if (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</span><br><span class="line">	dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, DISPATCH_QUEUE_OVERCOMMIT);</span><br><span class="line">	timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">        dispatch_retain(timeout_timer);</span><br><span class="line">	timeout_context-&gt;ds = timeout_timer;</span><br><span class="line">	timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl);</span><br><span class="line">	timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</span><br><span class="line">	dispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context</span><br><span class="line">	dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</span><br><span class="line">        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</span><br><span class="line">        uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL);</span><br><span class="line">        dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL);</span><br><span class="line">        dispatch_resume(timeout_timer);</span><br><span class="line">    &#125; else &#123; // infinite timeout</span><br><span class="line">        seconds = 9999999999.0;</span><br><span class="line">        timeout_context-&gt;termTSR = UINT64_MAX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Boolean didDispatchPortLastTime = true;</span><br><span class="line">    int32_t retVal = 0;</span><br><span class="line">    do &#123;</span><br><span class="line">        uint8_t msg_buffer[3 * 1024];</span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">        mach_msg_header_t *msg = NULL;</span><br><span class="line">        mach_port_t livePort = MACH_PORT_NULL;</span><br><span class="line">#elif DEPLOYMENT_TARGET_WINDOWS</span><br><span class="line">        HANDLE livePort = NULL;</span><br><span class="line">        Boolean windowsMessageReceived = false;</span><br><span class="line">#endif</span><br><span class="line">	__CFPortSet waitSet = rlm-&gt;_portSet;</span><br><span class="line"></span><br><span class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</span><br><span class="line"></span><br><span class="line">        /* 通知 Observers: RunLoop 将触发 Timer 回调 */</span><br><span class="line"></span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line"></span><br><span class="line">        /* 通知 Observers: RunLoop 将触发 Source0 (非port) 回调 */</span><br><span class="line"></span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line"></span><br><span class="line">        /* RunLoop 执行被加入的block */</span><br><span class="line"></span><br><span class="line">	__CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line"></span><br><span class="line">        /* RunLoop 处理 Source0 (非port) 回调 */</span><br><span class="line"></span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        if (sourceHandledThisLoop) &#123;</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);</span><br><span class="line"></span><br><span class="line">        if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">            msg = (mach_msg_header_t *)msg_buffer;</span><br><span class="line">            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0)) &#123;</span><br><span class="line">                goto handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">#elif DEPLOYMENT_TARGET_WINDOWS</span><br><span class="line">            if (__CFRunLoopWaitForMultipleObjects(NULL, &amp;dispatchPort, 0, 0, &amp;livePort, NULL)) &#123;</span><br><span class="line">                goto handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        didDispatchPortLastTime = false;</span><br><span class="line"></span><br><span class="line">    /* 通知 Observers: RunLoop 的线程即将进入休眠 */</span><br><span class="line"></span><br><span class="line">	if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">	__CFRunLoopSetSleeping(rl);</span><br><span class="line">	// do not do any user callouts after this point (after notifying of sleeping)</span><br><span class="line"></span><br><span class="line">        // Must push the local-to-this-activation ports in on every loop</span><br><span class="line">        // iteration, as this mode could be run re-entrantly and we don&apos;t</span><br><span class="line">        // want these ports to get serviced.</span><br><span class="line"></span><br><span class="line">        __CFPortSetInsert(dispatchPort, waitSet);</span><br><span class="line">        </span><br><span class="line">	__CFRunLoopModeUnlock(rlm);</span><br><span class="line">	__CFRunLoopUnlock(rl);</span><br><span class="line"></span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">        do &#123;</span><br><span class="line">            if (kCFUseCollectableAllocator) &#123;</span><br><span class="line">                objc_clear_stack(0);</span><br><span class="line">                memset(msg_buffer, 0, sizeof(msg_buffer));</span><br><span class="line">            &#125;</span><br><span class="line">            msg = (mach_msg_header_t *)msg_buffer;</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY);</span><br><span class="line">            </span><br><span class="line">            if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class="line">                // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.</span><br><span class="line">                while (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</span><br><span class="line">                if (rlm-&gt;_timerFired) &#123;</span><br><span class="line">                    // Leave livePort as the queue port, and service timers below</span><br><span class="line">                    rlm-&gt;_timerFired = false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Go ahead and leave the inner loop.</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (1);</span><br><span class="line">#else</span><br><span class="line">        if (kCFUseCollectableAllocator) &#123;</span><br><span class="line">            objc_clear_stack(0);</span><br><span class="line">            memset(msg_buffer, 0, sizeof(msg_buffer));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* RunLoop 调用 mach_msg 阻塞等待接受 mach_port 的消息 */</span><br><span class="line"></span><br><span class="line">        msg = (mach_msg_header_t *)msg_buffer;</span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY);</span><br><span class="line">#endif</span><br><span class="line">...</span><br><span class="line">        __CFRunLoopLock(rl);</span><br><span class="line">        __CFRunLoopModeLock(rlm);</span><br><span class="line"></span><br><span class="line">        // Must remove the local-to-this-activation ports in on every loop</span><br><span class="line">        // iteration, as this mode could be run re-entrantly and we don&apos;t</span><br><span class="line">        // want these ports to get serviced. Also, we don&apos;t want them left</span><br><span class="line">        // in there if this function returns.</span><br><span class="line"></span><br><span class="line">        __CFPortSetRemove(dispatchPort, waitSet);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line"></span><br><span class="line">        // user callouts now OK again</span><br><span class="line">        </span><br><span class="line">        /* 通知 Observers: RunLoop 的线程刚刚被唤醒了 */</span><br><span class="line"></span><br><span class="line">	__CFRunLoopUnsetSleeping(rl);</span><br><span class="line">	if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line">        handle_msg:;</span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line">...</span><br><span class="line">        if (MACH_PORT_NULL == livePort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</span><br><span class="line">            // handle nothing</span><br><span class="line">        &#125; else if (livePort == rl-&gt;_wakeUpPort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</span><br><span class="line">            // do nothing on Mac OS</span><br><span class="line">#if DEPLOYMENT_TARGET_WINDOWS</span><br><span class="line">            // Always reset the wake up port, or risk spinning forever</span><br><span class="line">            ResetEvent(rl-&gt;_wakeUpPort);</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">        else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class="line"></span><br><span class="line">            /* Timer 到了，触发这个Timer的回调 */</span><br><span class="line"></span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                // Re-arm the next timer, because we apparently fired early</span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">#if USE_MK_TIMER_TOO</span><br><span class="line">        else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            // On Windows, we have observed an issue where the timer port is set before the time which we requested it to be set. For example, we set the fire time to be TSR 167646765860, but it is actually observed firing at TSR 167646764145, which is 1715 ticks early. The result is that, when __CFRunLoopDoTimers checks to see if any of the run loop timers should be firing, it appears to be &apos;too early&apos; for the next timer, and no timers are handled.</span><br><span class="line">            // In this case, the timer port has been automatically reset (since it was returned from MsgWaitForMultipleObjectsEx), and if we do not re-arm it, then no timers will ever be serviced again unless something adjusts the timer list (e.g. adding or removing timers). The fix for the issue is to reset the timer here if CFRunLoopDoTimers did not handle a timer itself. 9308754</span><br><span class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                // Re-arm the next timer</span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">        else if (livePort == dispatchPort) &#123;</span><br><span class="line"></span><br><span class="line">            /* 若有main dispatch，执行回调 */</span><br><span class="line"></span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">            __CFRunLoopUnlock(rl);</span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);</span><br><span class="line">	        __CFRunLoopLock(rl);</span><br><span class="line">	        __CFRunLoopModeLock(rlm);</span><br><span class="line"> 	        sourceHandledThisLoop = true;</span><br><span class="line">            didDispatchPortLastTime = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            /* Source1 (基于port) 发出事件了，处理这个事件 */</span><br><span class="line"></span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</span><br><span class="line">            // Despite the name, this works for windows handles as well</span><br><span class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">            if (rls) &#123;</span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">		mach_msg_header_t *reply = NULL;</span><br><span class="line">		sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">		if (NULL != reply) &#123;</span><br><span class="line">		    (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</span><br><span class="line">		    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</span><br><span class="line">		&#125;</span><br><span class="line">...</span><br><span class="line">#endif</span><br><span class="line">	    &#125;</span><br><span class="line">        &#125; </span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">        if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</span><br><span class="line">#endif</span><br><span class="line">        </span><br><span class="line">    /* 执行加入到Loop的block */</span><br><span class="line">        </span><br><span class="line">	__CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">    /* 处理完事件或超时或被强制停止 将退出循环 */</span><br><span class="line"></span><br><span class="line">	if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">	    retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">	&#125; else if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">	    retVal = kCFRunLoopRunStopped;</span><br><span class="line">	&#125; else if (rlm-&gt;_stopped) &#123;</span><br><span class="line">	    rlm-&gt;_stopped = false;</span><br><span class="line">	    retVal = kCFRunLoopRunStopped;</span><br><span class="line">	&#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">	    retVal = kCFRunLoopRunFinished;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125; while (0 == retVal);</span><br><span class="line"></span><br><span class="line">    if (timeout_timer) &#123;</span><br><span class="line">        dispatch_source_cancel(timeout_timer);</span><br><span class="line">        dispatch_release(timeout_timer);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        free(timeout_context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="OSX和iOS架构"><a href="#OSX和iOS架构" class="headerlink" title="OSX和iOS架构"></a>OSX和iOS架构</h3><p><img src="/images/2039514-2eedcaceda05fc7c.png" alt=""></p>
<p><img src="/images/2039514-e5d3e1ba0b9fb3a3.png" alt=""></p>
<p>RunLoop的Source0负责处理App内部事件，而Souces1则接收系统发来的Mach Message再转发给Souces0处理。</p>
<pre><code>系统注册了一个基于port 的source ，回调函数为__IOHIDEventSystemClientQueueCallback。通过测试，无论你点击屏幕，甚至是你晃动手机，都是触发这个回调。

经查资料知道这首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。

_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。
</code></pre><p>以下是点击Button后的线程堆栈</p>
<p><img src="/images/b41f651c-7fc6-4e8d-9b93-02cf5af1b687.png" alt=""></p>
<h3 id="App-启动后-RunLoop-的状态"><a href="#App-启动后-RunLoop-的状态" class="headerlink" title="App 启动后 RunLoop 的状态"></a>App 启动后 RunLoop 的状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">&lt;CFRunLoop 0x6000001f9300 [0x10306ec80]&gt;&#123;wakeup port = 0x2203, stopped = false, ignoreWakeUps = false, </span><br><span class="line">current mode = kCFRunLoopDefaultMode,</span><br><span class="line">common modes = &lt;CFBasicHash 0x600000243ae0 [0x10306ec80]&gt;&#123;type = mutable set, count = 2,</span><br><span class="line">entries =&gt;</span><br><span class="line">	0 : &lt;CFString 0x10713ae88 [0x10306ec80]&gt;&#123;contents = &quot;UITrackingRunLoopMode&quot;&#125;</span><br><span class="line">	2 : &lt;CFString 0x103044818 [0x10306ec80]&gt;&#123;contents = &quot;kCFRunLoopDefaultMode&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line">,</span><br><span class="line">common mode items = &lt;CFBasicHash 0x600000244050 [0x10306ec80]&gt;&#123;type = mutable set, count = 13,</span><br><span class="line">entries =&gt;</span><br><span class="line">	0 : &lt;CFRunLoopSource 0x600000176740 [0x10306ec80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x10fe7a75a)&#125;&#125;</span><br><span class="line">	1 : &lt;CFRunLoopObserver 0x604000139c80 [0x10306ec80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (0x10b6774ce), context = &lt;CFRunLoopObserver context 0x0&gt;&#125;</span><br><span class="line">	4 : &lt;CFRunLoopSource 0x604000175d80 [0x10306ec80]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 18703, subsystem = 0x1070f1fe8, context = 0x0&#125;&#125;</span><br><span class="line">	8 : &lt;CFRunLoopObserver 0x604000139780 [0x10306ec80]&gt;&#123;valid = Yes, activities = 0x20, repeats = Yes, order = 0, callout = _UIGestureRecognizerUpdateObserver (0x10655e6b3), context = &lt;CFRunLoopObserver context 0x6000000d68f0&gt;&#125;</span><br><span class="line">	10 : &lt;CFRunLoopSource 0x6040001762c0 [0x10306ec80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x604000144150, callout = __handleEventQueue (0x1068d5bb2)&#125;&#125;</span><br><span class="line">	11 : &lt;CFRunLoopObserver 0x6040001395a0 [0x10306ec80]&gt;&#123;valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x105f78d92), context = &lt;CFArray 0x6040002493c0 [0x10306ec80]&gt;&#123;type = mutable-small, count = 1, values = (</span><br><span class="line">	0 : &lt;0x7fe21e008160&gt;</span><br><span class="line">)&#125;&#125;</span><br><span class="line">	12 : &lt;CFRunLoopSource 0x600000175900 [0x10306ec80]&gt;&#123;signalled = Yes, valid = Yes, order = 0, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x6000000ab5e0, callout = FBSSerialQueueRunLoopSourceHandler (0x11165482f)&#125;&#125;</span><br><span class="line">	13 : &lt;CFRunLoopSource 0x604000176140 [0x10306ec80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 1, info = 0x3103, callout = PurpleEventCallback (0x10fe7cbf7)&#125;&#125;</span><br><span class="line">	14 : &lt;CFRunLoopObserver 0x6040001393c0 [0x10306ec80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, callout = _afterCACommitHandler (0x105fa7e1c), context = &lt;CFRunLoopObserver context 0x7fe21de01090&gt;&#125;</span><br><span class="line">	15 : &lt;CFRunLoopObserver 0x604000139320 [0x10306ec80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x105f78d92), context = &lt;CFArray 0x6040002493c0 [0x10306ec80]&gt;&#123;type = mutable-small, count = 1, values = (</span><br><span class="line">	0 : &lt;0x7fe21e008160&gt;</span><br><span class="line">)&#125;&#125;</span><br><span class="line">	16 : &lt;CFRunLoopObserver 0x604000139460 [0x10306ec80]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, callout = _beforeCACommitHandler (0x105fa7da1), context = &lt;CFRunLoopObserver context 0x7fe21de01090&gt;&#125;</span><br><span class="line">	17 : &lt;CFRunLoopSource 0x604000178000 [0x10306ec80]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 22275, subsystem = 0x10710c668, context = 0x600000223c80&#125;&#125;</span><br><span class="line">	22 : &lt;CFRunLoopSource 0x604000176680 [0x10306ec80]&gt;&#123;signalled = No, valid = Yes, order = -2, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x60400024b370, callout = __handleHIDEventFetcherDrain (0x1068d5bbe)&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">,</span><br><span class="line">modes = &lt;CFBasicHash 0x600000243ba0 [0x10306ec80]&gt;&#123;type = mutable set, count = 4,</span><br><span class="line">entries =&gt;</span><br><span class="line">	2 : &lt;CFRunLoopMode 0x60000019de90 [0x10306ec80]&gt;&#123;name = UITrackingRunLoopMode, port set = 0x2e03, queue = 0x600000144570, source = 0x60000019df60 (not fired), timer port = 0x4e03, </span><br><span class="line">	sources0 = &lt;CFBasicHash 0x60400024a620 [0x10306ec80]&gt;&#123;type = mutable set, count = 4,</span><br><span class="line">entries =&gt;</span><br><span class="line">	0 : &lt;CFRunLoopSource 0x600000176740 [0x10306ec80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x10fe7a75a)&#125;&#125;</span><br><span class="line">	2 : &lt;CFRunLoopSource 0x6040001762c0 [0x10306ec80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x604000144150, callout = __handleEventQueue (0x1068d5bb2)&#125;&#125;</span><br><span class="line">	4 : &lt;CFRunLoopSource 0x604000176680 [0x10306ec80]&gt;&#123;signalled = No, valid = Yes, order = -2, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x60400024b370, callout = __handleHIDEventFetcherDrain (0x1068d5bbe)&#125;&#125;</span><br><span class="line">	5 : &lt;CFRunLoopSource 0x600000175900 [0x10306ec80]&gt;&#123;signalled = Yes, valid = Yes, order = 0, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x6000000ab5e0, callout = FBSSerialQueueRunLoopSourceHandler (0x11165482f)&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">,</span><br><span class="line">	sources1 = &lt;CFBasicHash 0x60400024a5f0 [0x10306ec80]&gt;&#123;type = mutable set, count = 3,</span><br><span class="line">entries =&gt;</span><br><span class="line">	0 : &lt;CFRunLoopSource 0x604000178000 [0x10306ec80]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 22275, subsystem = 0x10710c668, context = 0x600000223c80&#125;&#125;</span><br><span class="line">	1 : &lt;CFRunLoopSource 0x604000176140 [0x10306ec80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 1, info = 0x3103, callout = PurpleEventCallback (0x10fe7cbf7)&#125;&#125;</span><br><span class="line">	2 : &lt;CFRunLoopSource 0x604000175d80 [0x10306ec80]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 18703, subsystem = 0x1070f1fe8, context = 0x0&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">,</span><br><span class="line">	observers = &lt;1,6,0x60400024b2e0&gt;,[0x6040001395a0--1283488] [0x604000139780--1283968] [0x604000139460--1283168] [0x604000139c80--1285248] [0x6040001393c0--1283008] [0x604000139320--1282848] ,</span><br><span class="line">	timers = (null),</span><br><span class="line">	currently 559045158 (106811992001349) / soft deadline in: 1.84466373e+10 sec (@ -1) / hard deadline in: 1.84466373e+10 sec (@ -1)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">	3 : &lt;CFRunLoopMode 0x60400019d4d0 [0x10306ec80]&gt;&#123;name = GSEventReceiveRunLoopMode, port set = 0x2f03, queue = 0x604000144360, source = 0x60400019d5a0 (not fired), timer port = 0x3003, </span><br><span class="line">	sources0 = &lt;CFBasicHash 0x600000244140 [0x10306ec80]&gt;&#123;type = mutable set, count = 1,</span><br><span class="line">entries =&gt;</span><br><span class="line">	0 : &lt;CFRunLoopSource 0x600000176740 [0x10306ec80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x10fe7a75a)&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">,</span><br><span class="line">	sources1 = &lt;CFBasicHash 0x600000244170 [0x10306ec80]&gt;&#123;type = mutable set, count = 1,</span><br><span class="line">entries =&gt;</span><br><span class="line">	1 : &lt;CFRunLoopSource 0x604000176200 [0x10306ec80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 1, info = 0x3103, callout = PurpleEventCallback (0x10fe7cbf7)&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">,</span><br><span class="line">	observers = (null),</span><br><span class="line">	timers = (null),</span><br><span class="line">	currently 559045158 (106811993680557) / soft deadline in: 1.84466373e+10 sec (@ -1) / hard deadline in: 1.84466373e+10 sec (@ -1)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">	4 : &lt;CFRunLoopMode 0x60000019db50 [0x10306ec80]&gt;&#123;name = kCFRunLoopDefaultMode, port set = 0x2103, queue = 0x6000001442b0, source = 0x60000019dc20 (not fired), timer port = 0x5403, </span><br><span class="line">	sources0 = &lt;CFBasicHash 0x60400024a650 [0x10306ec80]&gt;&#123;type = mutable set, count = 4,</span><br><span class="line">entries =&gt;</span><br><span class="line">	0 : &lt;CFRunLoopSource 0x600000176740 [0x10306ec80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x10fe7a75a)&#125;&#125;</span><br><span class="line">	2 : &lt;CFRunLoopSource 0x6040001762c0 [0x10306ec80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x604000144150, callout = __handleEventQueue (0x1068d5bb2)&#125;&#125;</span><br><span class="line">	4 : &lt;CFRunLoopSource 0x604000176680 [0x10306ec80]&gt;&#123;signalled = No, valid = Yes, order = -2, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x60400024b370, callout = __handleHIDEventFetcherDrain (0x1068d5bbe)&#125;&#125;</span><br><span class="line">	5 : &lt;CFRunLoopSource 0x600000175900 [0x10306ec80]&gt;&#123;signalled = Yes, valid = Yes, order = 0, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x6000000ab5e0, callout = FBSSerialQueueRunLoopSourceHandler (0x11165482f)&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">,</span><br><span class="line">	sources1 = &lt;CFBasicHash 0x60400024a3e0 [0x10306ec80]&gt;&#123;type = mutable set, count = 3,</span><br><span class="line">entries =&gt;</span><br><span class="line">	0 : &lt;CFRunLoopSource 0x604000178000 [0x10306ec80]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 22275, subsystem = 0x10710c668, context = 0x600000223c80&#125;&#125;</span><br><span class="line">	1 : &lt;CFRunLoopSource 0x604000176140 [0x10306ec80]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 1, info = 0x3103, callout = PurpleEventCallback (0x10fe7cbf7)&#125;&#125;</span><br><span class="line">	2 : &lt;CFRunLoopSource 0x604000175d80 [0x10306ec80]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 18703, subsystem = 0x1070f1fe8, context = 0x0&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">,</span><br><span class="line">	observers = &lt;1,6,0x60400024b4c0&gt;,[0x6040001395a0--1283488] [0x604000139780--1283968] [0x604000139460--1283168] [0x604000139c80--1285248] [0x6040001393c0--1283008] [0x604000139320--1282848] ,</span><br><span class="line">	timers = &lt;CFArray 0x6000000aa7a0 [0x10306ec80]&gt;&#123;type = mutable-small, count = 1, values = (</span><br><span class="line">	0 : &lt;CFRunLoopTimer 0x600000176c80 [0x10306ec80]&gt;&#123;valid = Yes, firing = No, interval = 0, tolerance = 0, next fire date = 559045126 (-32.3797849 @ 106779616101844), callout = (Delayed Perform) UIApplication _accessibilitySetUpQuickSpeak (0x103dac849 / 0x10646931b) (/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/UIKit.framework/UIKit), context = &lt;CFRunLoopTimer context 0x60000026a700&gt;&#125;</span><br><span class="line">)&#125;,</span><br><span class="line">	currently 559045158 (106811993736551) / soft deadline in: 1.8446744e+10 sec (@ 106779616101844) / hard deadline in: 1.8446744e+10 sec (@ 106779616101844)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">	5 : &lt;CFRunLoopMode 0x60400019d810 [0x10306ec80]&gt;&#123;name = kCFRunLoopCommonModes, port set = 0x440b, queue = 0x6040001448e0, source = 0x60400019db50 (not fired), timer port = 0x3f0b, </span><br><span class="line">	sources0 = (null),</span><br><span class="line">	sources1 = (null),</span><br><span class="line">	observers = (null),</span><br><span class="line">	timers = (null),</span><br><span class="line">	currently 559045158 (106811995881018) / soft deadline in: 1.84466373e+10 sec (@ -1) / hard deadline in: 1.84466373e+10 sec (@ -1)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>App启动后系统添加了6个Observer,其中2个的回调都是_wrapRunLoopWithAutoreleasePoolHandler。</p>
<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>
<p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>回调是_UIGestureRecognizerUpdateObserver的 Observer 在 BeforeWaiting(即将进入休眠) 时执行GestureRecognizer的回调</p>
<p>回调是_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv的 Observer 在BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 时会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面</p>
<h3 id="关于网络"><a href="#关于网络" class="headerlink" title="关于网络"></a>关于网络</h3><h4 id="Runloop-amp-CFSocket"><a href="#Runloop-amp-CFSocket" class="headerlink" title="Runloop &amp; CFSocket"></a>Runloop &amp; CFSocket</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static void __CFSocketSendNameRegistryRequest(CFSocketSignature *signature, CFDictionaryRef requestDictionary, __CFSocketNameRegistryResponse *response, CFTimeInterval timeout) &#123;</span><br><span class="line">    CFDataRef requestData = NULL;</span><br><span class="line">    CFSocketContext context = &#123;0, response, NULL, NULL, NULL&#125;;</span><br><span class="line">    CFSocketRef s = NULL;</span><br><span class="line">    CFRunLoopSourceRef source = NULL;</span><br><span class="line">    if (NULL != response-&gt;error) *(response-&gt;error) = kCFSocketError;</span><br><span class="line">    requestData = CFPropertyListCreateXMLData(kCFAllocatorSystemDefault, requestDictionary);</span><br><span class="line">    if (NULL != requestData) &#123;</span><br><span class="line">        if (NULL != response-&gt;error) *(response-&gt;error) = kCFSocketTimeout;</span><br><span class="line">        s = CFSocketCreateConnectedToSocketSignature(kCFAllocatorSystemDefault, signature, kCFSocketDataCallBack, __CFSocketHandleNameRegistryReply, &amp;context, timeout);</span><br><span class="line">        if (NULL != s) &#123;</span><br><span class="line">            if (kCFSocketSuccess == CFSocketSendData(s, NULL, requestData, timeout)) &#123;</span><br><span class="line">                source = CFSocketCreateRunLoopSource(kCFAllocatorSystemDefault, s, 0);</span><br><span class="line">                CFRunLoopAddSource(CFRunLoopGetCurrent(), source, __kCFSocketRegistryRequestRunLoopMode);</span><br><span class="line">                CFRunLoopRunInMode(__kCFSocketRegistryRequestRunLoopMode, timeout, false);</span><br><span class="line">                CFRelease(source);</span><br><span class="line">            &#125;</span><br><span class="line">            CFSocketInvalidate(s);</span><br><span class="line">            CFRelease(s);</span><br><span class="line">        &#125;</span><br><span class="line">        CFRelease(requestData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __CFSocketHandleRead(CFSocketRef s, Boolean causedByTimeout) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">static void __CFSocketHandleWrite(CFSocketRef s, Boolean callBackNow) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>CFSocket 是最底层的接口，只负责 socket 通信。CFNetwork 是基于 CFSocket 等接口的上层封装。</p>
<h3 id="RunLoop-的实例"><a href="#RunLoop-的实例" class="headerlink" title="RunLoop 的实例"></a>RunLoop 的实例</h3><h4 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];</span><br><span class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">+ (NSThread *)networkRequestThread &#123;</span><br><span class="line">    static NSThread *_networkRequestThread = nil;</span><br><span class="line">    static dispatch_once_t oncePredicate;</span><br><span class="line">    dispatch_once(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    return _networkRequestThread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)start &#123;</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    if ([self isCancelled]) &#123;</span><br><span class="line">        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</span><br><span class="line">    &#125; else if ([self isReady]) &#123;</span><br><span class="line">        self.state = AFOperationExecutingState;</span><br><span class="line">        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.msrily.com/2018/06/01/blog14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Richie Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Richie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/01/blog14/" itemprop="url">Objective-C Runtime</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-01T18:04:17+08:00">
                2018-06-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>初学 Objective-C 时把[receiver message]当成简单的方法调用，而无视了“发送消息”这句话的深刻含义。其实[receiver message]会被编译器转化为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector)</span><br></pre></td></tr></table></figure>
<p>如果消息含有参数，则为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>
<p>如果消息的接收者能够找到对应的selector，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个selector对应的实现内容，要么就干脆玩完崩溃掉。<br>现在可以看出[receiver message]真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送message这条消息，而receive将要如何响应这条消息，那就要看运行时发生的情况来决定了。</p>
<p>Objective-C 的 Runtime 铸就了它动态语言的特性，这些深层次的知识虽然平时写代码用的少一些，但是却是每个 Objective-C程序员需要了解的。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>因为Objective-C是一门动态语言，所以它总是想办法把一些决定工作从编译连接推迟到运行时。也就是说只有编译器是不够的，还需要一个运行时系统 (runtime system) 来执行编译后的代码。这就是 Objective-C Runtime 系统存在的意义，它是整个Objective-C运行框架的一块基石。</p>
<p>Runtime其实有两个版本:“modern”和 “legacy”。我们现在用的 Objective-C 2.0 采用的是现行(Modern)版的Runtime系统，只能运行在 iOS 和 OS X 10.5 之后的64位程序中。而OS X较老的32位程序仍采用 Objective-C 1中的（早期）Legacy 版本的 Runtime 系统。这两个版本最大的区别在于当你更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。</p>
<p>Runtime基本是用C和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在<a href="https://www.opensource.apple.com/source/objc4/" target="_blank" rel="noopener">这里</a>下到苹果维护的开源代码。苹果和GNU各自维护一个开源的runtime版本，这两个版本之间都在努力的保持一致。</p>
<h2 id="与Runtime交互"><a href="#与Runtime交互" class="headerlink" title="与Runtime交互"></a>与Runtime交互</h2><p>Objective-C从三种不同的层级上与 Runtime 系统进行交互，分别是通过 Objective-C 源代码，通过 Foundation 框架的NSObject类定义的方法，通过对 runtime 函数的直接调用。</p>
<p>Runtime 系统是一个由一系列函数和数据结构组成，具有公共接口的动态共享库。头文件存放于/usr/include/objc目录下。许多函数允许你用纯C代码来重复实现 Objective-C中同样的功能。虽然有一些方法构成了NSObject类的基础，但是你在写 Objective-C代码时一般不会直接用到这些函数的，除非是写一些 Objective-C与其他语言的桥接或是底层的debug工作。在<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html" target="_blank" rel="noopener">Objective-C Runtime Reference</a>中有对 Runtime 函数的详细文档。</p>
<h2 id="Runtime术语"><a href="#Runtime术语" class="headerlink" title="Runtime术语"></a>Runtime术语</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSend ( id self, SEL op, ... );</span><br></pre></td></tr></table></figure>
<h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><p>是selector在Objective-C中的表示类型（Swift中是Selector类），原型:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure></p>
<p>可以用 Objective-C编译器命令@selector()或者 Runtime 系统的sel_registerName函数来获得一个SEL类型的方法选择器。</p>
<h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_object *id;</span><br><span class="line">struct objc_object &#123; Class isa; &#125;;</span><br></pre></td></tr></table></figure>
<p>objc_object结构体包含一个isa指针，根据isa指针就可以顺藤摸瓜找到对象所属的类。</p>
<p>PS: isa指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用class方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类，这是一种叫做 isa-swizzling 的技术，详见官方文档</p>
<h4 id="class"><a href="#class" class="headerlink" title="class"></a>class</h4><p>是指向objc_class结构体的指针：typedef struct objc_class *Class;    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    const char *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>Objective-C 2.0 的头文件虽然没暴露出objc_class结构体更详细的设计，我们依然可以从Objective-C 1.0 的定义中小窥端倪：<br>在objc_class结构体中：ivars是objc_ivar_list指针；methodLists是指向objc_method_list指针的指针。也就是说可以动态修改*methodLists的值来添加成员方法，这也是Category实现的原理，同样解释了Category不能添加属性的原因。但可以在Category中添加@dynamic的属性，并利用运行期动态提供存取方法或干脆动态转发；或者干脆使用关联度对象（AssociatedObject）。</p>
<p>其中objc_ivar_list和objc_method_list分别是成员变量列表和方法列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct objc_ivar_list &#123;</span><br><span class="line">    int ivar_count                                           OBJC2_UNAVAILABLE;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">    /* variable length structure */</span><br><span class="line">    struct objc_ivar ivar_list[1]                            OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">struct objc_method_list &#123;</span><br><span class="line">    struct objc_method_list *obsolete                        OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    int method_count                                         OBJC2_UNAVAILABLE;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">    /* variable length structure */</span><br><span class="line">    struct objc_method method_list[1]                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不知道你是否注意到了objc_class中也有一个isa对象，这是因为一个 ObjC 类本身同时也是一个对象，为了处理类和对象的关系，runtime 库创建了一种叫做元类 (Meta Class) 的东西，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据。类方法就定义于此处，因为这些方法可以理解成类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。当你发出一个类似[NSObject alloc]的消息时，你事实上是把这个消息发给了一个类对象 (Class Object) ，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类 (root meta class) 的实例。所有的元类最终都指向根元类为其超类。所有的元类的方法列表都有能够响应消息的类方法。所以当 [NSObject alloc] 这条消息发给类对象的时候，objc_msgSend()会去它的元类里面去查找能够响应消息的方法，如果找到了，然后对这个类对象执行方法调用。</p>
<p><img src="/images/8f899651-b423-4683-8579-01d6b82b9265.png" alt=""></p>
<p>实线是 super_class 指针，虚线是isa指针。 有趣的是根元类的超类是NSObject，而isa指向了自己，而NSObject的超类为nil，也就是它没有超类。</p>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p>是一种代表类中的某个方法的类型：typedef struct objc_method *Method;    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    char *method_types                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法名类型为SEL，前面提到过相同名字的方法即使在不同类中定义，它们的方法选择器也相同。</p>
<p>方法类型method_types是个char指针，其实存储着方法的参数类型和返回值类型。</p>
<p>method_imp指向了方法的实现，本质上是一个函数指针，后面会详细讲到。</p>
<h4 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h4><p>是一种代表类中实例变量的类型：typedef struct objc_ivar *Ivar;    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct objc_ivar &#123;</span><br><span class="line">    char *ivar_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    char *ivar_type                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    int ivar_offset                                          OBJC2_UNAVAILABLE;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void printIvarOFClass(NSObject *object, void (^block)(NSString *key,  NSString *valueType, id value)) &#123;</span><br><span class="line">    unsigned int outCount = 0;</span><br><span class="line">    Ivar *vars = class_copyIvarList([object class], &amp;outCount);</span><br><span class="line">    for (unsigned int i = 0; i &lt; outCount; ++i) &#123;</span><br><span class="line">        Ivar ivar = vars[i];</span><br><span class="line">        </span><br><span class="line">        NSString *key = [NSString stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line">        </span><br><span class="line">        NSString *type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];</span><br><span class="line">        </span><br><span class="line">	 block(key, type, [object valueForKey:key]);</span><br><span class="line">    &#125;</span><br><span class="line">    free(vars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作用是返回一个类的每一个变量名、类型及值</span><br></pre></td></tr></table></figure>
<h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h4><p>在objc.h中的定义是：typedef id (*IMP)(id, SEL, …);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct objc_ivar &#123;</span><br><span class="line">    char *ivar_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    char *ivar_type                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    int ivar_offset                                          OBJC2_UNAVAILABLE;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它就是一个函数指针，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。</p>
<p>你会发现IMP指向的方法与objc_msgSend函数类型相同，参数都包含id和SEL类型。每个方法名都对应一个SEL类型的方法选择器，而每个实例对象中的SEL对应的方法实现肯定是唯一的，通过一组id和SEL参数就能确定唯一的方法实现地址；反之亦然。</p>
<h4 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h4><p>在runtime.h中的定义是：typedef struct objc_cache *Cache;    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct objc_cache &#123;</span><br><span class="line">    unsigned int mask /* total = mask + 1 */                 OBJC2_UNAVAILABLE;</span><br><span class="line">    unsigned int occupied                                    OBJC2_UNAVAILABLE;</span><br><span class="line">    Method buckets[1]                                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Cache为方法调用的性能进行优化，通俗地讲，每当实例对象接收到一个消息时，它不会直接在isa指向的类的方法列表中遍历查找能够响应消息的方法，因为这样效率太低了，而是优先在Cache中查找。Runtime 系统会把被调用的方法存到Cache中（理论上讲一个方法如果被调用，那么它有可能今后还会被调用），下次查找的时候效率更高。这跟计算机组成原理中学过的 CPU 绕过主存先访问Cache的道理挺像.</p>
<p><img src="/images/98b6ab0c-3e96-4fd4-8650-1b51ae910fa3.png" alt=""></p>
<h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>Objective-C中发送消息是用中括号（[]）把接收者和消息括起来，而直到运行时才会把消息与方法实现绑定。</p>
<p>有关消息发送和消息转发机制的原理，可以查看这篇文章。</p>
<p>objc_msgSend函数</p>
<p>在引言中已经对objc_msgSend进行了一点介绍，看起来像是objc_msgSend返回了数据，其实objc_msgSend从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤：<br>检测这个 selector 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 retain, release 这些函数了。</p>
<p>检测这个 target 是不是 nil 对象。 Objective-C的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉。<br>如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了找得到就跳到对应的函数去执行。</p>
<p>如果 cache 找不到就找一下方法分发表。</p>
<p>如果分发表找不到就到超类的分发表去找，一直找，直到找到NSObject类为止。</p>
<p>如果还找不到就要开始进入动态方法解析。</p>
<p><img src="/images/cc11b235-e43a-4bb1-8a6f-cafb6459ffea.png" alt=""></p>
<p>编译器会根据情况在objc_msgSend, objc_msgSend_stret, objc_msgSendSuper, 或objc_msgSendSuper_stret四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有”Super”的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有”stret”的函数。</p>
<p>当objc_msgSend找到方法对应的实现时，它将直接调用该方法实现，并将消息中所有的参数都传递给方法实现,同时,它还将传递两个隐藏的参数（在代码被编译时被插入实现）:<br>接收消息的对象（也就是self指向的内容）<br>方法选择器（_cmd指向的内容）</p>
<p>在这两个参数中，self 更有用。实际上,它是在方法实现中访问消息接收者对象的实例变量的途径。而当方法中的super关键字接收到消息时，编译器会创建一个objc_super结构体：<br>struct objc_super { id receiver; Class class; };<br>这个结构体指明了消息应该被传递给特定超类的定义。但receiver仍然是self本身，这点需要注意，因为当我们想通过[super class]获取超类时，编译器只是将指向self的id指针和class的SEL传递给了objc_msgSendSuper函数，因为只有在NSObject类才能找到class方法，然后class方法调用object_getClass()，接着调用objc_msgSend(objc_super-&gt;receiver, @selector(class))，传入的第一个参数是指向self的id指针，与调用[self class]相同，所以我们得到的永远都是self的类型。</p>
<p>在IMP那节提到过可以避开消息绑定而直接获取方法的地址并调用方法。这种做法很少用，除非是需要持续大量重复调用某方法的极端情况，避开消息发送泛滥而直接调用该方法会更高效。</p>
<h4 id="获取方法地址"><a href="#获取方法地址" class="headerlink" title="获取方法地址"></a>获取方法地址</h4><p>NSObject类中有个methodForSelector:实例方法，你可以用它来获取某个方法选择器对应的IMP，举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void (*setter)(id, SEL, BOOL);</span><br><span class="line">int i;</span><br><span class="line">setter = (void (*)(id, SEL, BOOL))[target</span><br><span class="line">   	methodForSelector:@selector(setFilled:)];</span><br><span class="line">for ( i = 0 ; i &lt; 1000 ; i++ )</span><br><span class="line">   		setter(targetList[i], @selector(setFilled:), YES);</span><br></pre></td></tr></table></figure>
<p>当方法被当做函数调用时，上节提到的两个隐藏参数就需要我们明确给出了。上面的例子调用了1000次函数，你可以试试直接给target发送1000次setFilled:消息会花多久。</p>
<h2 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h2><p>你可以动态地提供一个方法的实现。例如我们可以用@dynamic关键字在类的实现文件中修饰一个属性：@dynamic propertyName;<br>这表明我们会为这个属性动态提供存取方法，也就是说编译器不会再默认为我们生成setPropertyName:和propertyName方法，而需要我们动态提供。我们可以通过分别重载resolveInstanceMethod:和resolveClassMethod:方法分别添加实例方法实现和类方法实现。因为当 Runtime 系统在Cache和方法分发表中（包括超类）找不到要执行的方法时，Runtime会调用resolveInstanceMethod:或resolveClassMethod:来给程序员一次动态添加方法实现的机会。我们需要用class_addMethod函数完成向特定类添加特定方法实现的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void dynamicMethodIMP(id self, SEL _cmd) &#123;</span><br><span class="line">    // implementation ....</span><br><span class="line">&#125;</span><br><span class="line">@implementation XXX</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)aSEL</span><br><span class="line">&#123;</span><br><span class="line">    if (aSEL == @selector(resolveThisMethodDynamically)) &#123;</span><br><span class="line">          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);</span><br><span class="line">          return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>上面的例子为resolveThisMethodDynamically方法添加了实现内容，也就是dynamicMethodIMP方法中的代码。其中 “v@:” 表示返回值和参数，这个符号涉及<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">Type Encoding</a>。</p>
<h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p><img src="/images/47701c98-dc69-43ee-89b5-ae8c6cbcf12f.png" alt=""></p>
<h3 id="重定向-转发"><a href="#重定向-转发" class="headerlink" title="重定向/转发"></a>重定向/转发</h3><p>在消息转发机制执行前，Runtime 系统会再给我们一次偷梁换柱的机会，即通过重载- (id)forwardingTargetForSelector:(SEL)aSelector方法替换消息的接受者为其他对象：</p>
<p><img src="/images/b041dc15-d858-4647-8fa2-f9f2d80e3aa7.png" alt=""></p>
<p>毕竟消息转发要耗费更多时间，抓住这次机会将消息重定向给别人是个不错的选择。 如果此方法返回nil或self,则会进入消息转发机制(forwardInvocation:);否则将向返回的对象重新发送消息。</p>
<h2 id="健壮的实例变量-Non-Fragile-ivars"><a href="#健壮的实例变量-Non-Fragile-ivars" class="headerlink" title="健壮的实例变量(Non Fragile ivars)"></a>健壮的实例变量(Non Fragile ivars)</h2><p>在 Runtime 的现行版本中，最大的特点就是健壮的实例变量。当一个类被编译时，实例变量的布局也就形成了，它表明访问类的实例变量的位置。从对象头部开始，实例变量依次根据自己所占空间而产生位移：</p>
<p><img src="/images/7e4ec8e3-f464-41f4-a3ea-714fcffe4bf7.png" alt=""></p>
<p>上图左边是NSObject类的实例变量布局，右边是我们写的类的布局，也就是在超类后面加上我们自己类的实例变量，看起来不错。但试想如果哪天苹果更新了NSObject类，发布新版本的系统的话，那就悲剧了：</p>
<p><img src="/images/12a9cc3f-6a9a-4706-85a6-34187262470c.png" alt=""></p>
<p>我们自定义的类被划了两道线，那是因为那块区域跟超类重叠了。唯有苹果将超类改为以前的布局才能拯救我们，但这样也导致它们不能再拓展它们的框架了，因为成员变量布局被死死地固定了。在脆弱的实例变量(Fragile ivars) 环境下我们需要重新编译继承自 Apple 的类来恢复兼容性。那么在健壮的实例变量下会发生什么呢？</p>
<p><img src="/images/2739e14b-b67b-4339-8979-1c7654b676aa.png" alt=""></p>
<p>在健壮的实例变量下编译器生成的实例变量布局跟以前一样，但是当 runtime 系统检测到与超类有部分重叠时它会调整你新添加的实例变量的位移，那样你在子类中新添加的成员就被保护起来了。</p>
<h5 id="需要注意的是在健壮的实例变量下，不要使用sizeof-SomeClass-，而是用class-getInstanceSize-SomeClass-class-代替；也不要使用offsetof-SomeClass-SomeIvar-，而要用ivar-getOffset-class-getInstanceVariable-SomeClass-class-“SomeIvar”-来代替。"><a href="#需要注意的是在健壮的实例变量下，不要使用sizeof-SomeClass-，而是用class-getInstanceSize-SomeClass-class-代替；也不要使用offsetof-SomeClass-SomeIvar-，而要用ivar-getOffset-class-getInstanceVariable-SomeClass-class-“SomeIvar”-来代替。" class="headerlink" title="需要注意的是在健壮的实例变量下，不要使用sizeof(SomeClass)，而是用class_getInstanceSize([SomeClass class])代替；也不要使用offsetof(SomeClass, SomeIvar)，而要用ivar_getOffset(class_getInstanceVariable([SomeClass class], “SomeIvar”))来代替。"></a>需要注意的是在健壮的实例变量下，不要使用sizeof(SomeClass)，而是用class_getInstanceSize([SomeClass class])代替；也不要使用offsetof(SomeClass, SomeIvar)，而要用ivar_getOffset(class_getInstanceVariable([SomeClass class], “SomeIvar”))来代替。</h5><h2 id="Objective-C-Associated-Objects"><a href="#Objective-C-Associated-Objects" class="headerlink" title="Objective-C Associated Objects"></a>Objective-C Associated Objects</h2><p>在 OS X 10.6 之后，Runtime系统让Objc支持向对象动态添加变量。涉及到的函数有以下三个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void objc_setAssociatedObject ( id object, const void *key, id value, objc_AssociationPolicy policy );</span><br><span class="line">id objc_getAssociatedObject ( id object, const void *key );</span><br><span class="line">void objc_removeAssociatedObjects ( id object );</span><br></pre></td></tr></table></figure>
<p>这些方法以键值对的形式动态地向对象添加、获取或删除关联值。其中关联政策是一组枚举常量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">   OBJC_ASSOCIATION_ASSIGN  = 0,</span><br><span class="line">   OBJC_ASSOCIATION_RETAIN_NONATOMIC  = 1,</span><br><span class="line">   OBJC_ASSOCIATION_COPY_NONATOMIC  = 3,</span><br><span class="line">   OBJC_ASSOCIATION_RETAIN  = 01401,</span><br><span class="line">   OBJC_ASSOCIATION_COPY  = 01403</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这些常量对应着引用关联值的政策，也就是 Objc 内存管理的引用计数机制。</p>
<h2 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h2><p>之前所说的消息转发虽然功能强大，但需要我们了解并且能更改对应类的源代码，因为我们需要实现自己的转发逻辑。当我们无法触碰到某个类的源代码，却想更改这个类某个方法的实现时，该怎么办呢？可能继承类并重写方法是一种想法，但是有时无法达到目的。这里介绍的是 Method Swizzling ，它通过重新映射方法对应的实现来达到“偷天换日”的目的。跟消息转发相比，Method Swizzling 的做法更为隐蔽，甚至有些冒险，也增大了debug的难度。</p>

          
        
      
    </div>
    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.msrily.com/2018/05/24/blog13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Richie Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Richie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/24/blog13/" itemprop="url">GCD 队列探索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-24T18:44:25+08:00">
                2018-05-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>同步串行队列、异步串行队列和同步并行队列都只创建一个线程，而异步并行队列则创建多个线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.demo.1&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">//        dispatch_sync(queue1, ^&#123;</span><br><span class="line">//            NSLog(@&quot;%p&quot;, [NSThread currentThread]);</span><br><span class="line">//        &#125;);</span><br><span class="line">        /*</span><br><span class="line">         2018-09-17 18:38:38.654309+0800 testUI[31197:422120] 0x60400006ac80</span><br><span class="line">         2018-09-17 18:38:38.654448+0800 testUI[31197:422120] 0x60400006ac80</span><br><span class="line">         2018-09-17 18:38:38.654543+0800 testUI[31197:422120] 0x60400006ac80</span><br><span class="line">         2018-09-17 18:38:38.654643+0800 testUI[31197:422120] 0x60400006ac80</span><br><span class="line">         2018-09-17 18:38:38.654729+0800 testUI[31197:422120] 0x60400006ac80</span><br><span class="line">         2018-09-17 18:38:38.654879+0800 testUI[31197:422120] 0x60400006ac80</span><br><span class="line">         2018-09-17 18:38:38.654974+0800 testUI[31197:422120] 0x60400006ac80</span><br><span class="line">         2018-09-17 18:38:38.655165+0800 testUI[31197:422120] 0x60400006ac80</span><br><span class="line">         2018-09-17 18:38:38.655250+0800 testUI[31197:422120] 0x60400006ac80</span><br><span class="line">         2018-09-17 18:38:38.655363+0800 testUI[31197:422120] 0x60400006ac80</span><br><span class="line">         */</span><br><span class="line">//        dispatch_async(queue1, ^&#123;</span><br><span class="line">//            NSLog(@&quot;%p&quot;, [NSThread currentThread]);</span><br><span class="line">//        &#125;);</span><br><span class="line">        /*</span><br><span class="line">         2018-09-17 18:40:02.443306+0800 testUI[31225:423440] 0x604000269740</span><br><span class="line">         2018-09-17 18:40:02.443462+0800 testUI[31225:423440] 0x604000269740</span><br><span class="line">         2018-09-17 18:40:02.443560+0800 testUI[31225:423440] 0x604000269740</span><br><span class="line">         2018-09-17 18:40:02.443660+0800 testUI[31225:423440] 0x604000269740</span><br><span class="line">         2018-09-17 18:40:02.443830+0800 testUI[31225:423440] 0x604000269740</span><br><span class="line">         2018-09-17 18:40:02.444017+0800 testUI[31225:423440] 0x604000269740</span><br><span class="line">         2018-09-17 18:40:02.444403+0800 testUI[31225:423440] 0x604000269740</span><br><span class="line">         2018-09-17 18:40:02.444509+0800 testUI[31225:423440] 0x604000269740</span><br><span class="line">         2018-09-17 18:40:02.444737+0800 testUI[31225:423440] 0x604000269740</span><br><span class="line">         2018-09-17 18:40:02.445109+0800 testUI[31225:423440] 0x604000269740</span><br><span class="line">         */</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.demo.2&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">//        dispatch_sync(queue2, ^&#123;</span><br><span class="line">//            NSLog(@&quot;%p&quot;, [NSThread currentThread]);</span><br><span class="line">//        &#125;);</span><br><span class="line">        /*</span><br><span class="line">         2018-09-17 18:41:26.184301+0800 testUI[31260:424690] 0x600000063540</span><br><span class="line">         2018-09-17 18:41:26.184430+0800 testUI[31260:424690] 0x600000063540</span><br><span class="line">         2018-09-17 18:41:26.184519+0800 testUI[31260:424690] 0x600000063540</span><br><span class="line">         2018-09-17 18:41:26.184612+0800 testUI[31260:424690] 0x600000063540</span><br><span class="line">         2018-09-17 18:41:26.184721+0800 testUI[31260:424690] 0x600000063540</span><br><span class="line">         2018-09-17 18:41:26.184807+0800 testUI[31260:424690] 0x600000063540</span><br><span class="line">         2018-09-17 18:41:26.184906+0800 testUI[31260:424690] 0x600000063540</span><br><span class="line">         2018-09-17 18:41:26.185005+0800 testUI[31260:424690] 0x600000063540</span><br><span class="line">         2018-09-17 18:41:26.185111+0800 testUI[31260:424690] 0x600000063540</span><br><span class="line">         2018-09-17 18:41:26.185218+0800 testUI[31260:424690] 0x600000063540</span><br><span class="line">         */</span><br><span class="line">        dispatch_async(queue2, ^&#123;</span><br><span class="line">            NSLog(@&quot;%p&quot;, [NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        /*</span><br><span class="line">         2018-09-17 18:43:35.575104+0800 testUI[31313:426896] 0x604000469f40</span><br><span class="line">         2018-09-17 18:43:35.575104+0800 testUI[31313:426894] 0x600000271cc0</span><br><span class="line">         2018-09-17 18:43:35.575104+0800 testUI[31313:426895] 0x600000271bc0</span><br><span class="line">         2018-09-17 18:43:35.575126+0800 testUI[31313:426893] 0x600000272480</span><br><span class="line">         2018-09-17 18:43:35.575260+0800 testUI[31313:426894] 0x600000271cc0</span><br><span class="line">         2018-09-17 18:43:35.575270+0800 testUI[31313:426896] 0x604000469f40</span><br><span class="line">         2018-09-17 18:43:35.575304+0800 testUI[31313:426895] 0x600000271bc0</span><br><span class="line">         2018-09-17 18:43:35.575359+0800 testUI[31313:426893] 0x600000272480</span><br><span class="line">         2018-09-17 18:43:35.575386+0800 testUI[31313:426897] 0x600000271c40</span><br><span class="line">         2018-09-17 18:43:35.575394+0800 testUI[31313:426894] 0x600000271cc0</span><br><span class="line">         */</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最后一个结果有点意思，事实上没有创建10个线程，推测应该是此时GCD实现线程池的能力，以减少创建线程的开销，提高性能。</p>

          
        
      
    </div>
    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.msrily.com/2018/05/23/blog12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Richie Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Richie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/23/blog12/" itemprop="url">Objective C 类crash预防</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-23T16:29:23+08:00">
                2018-05-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Persion类</p>
<p><img src="/images/16a7155c-f0ff-47e9-bdca-47f517b30d1d.png" alt=""></p>
<p><img src="/images/0235ad78-fb93-420a-9acf-b7f7076dfd46.png" alt=""></p>
<p><img src="/images/93af98b9-0108-4069-a18b-579723fb30e7.png" alt=""></p>
<p>运行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-09-17 18:07:47.368888+0800 demo11[30894:402677] 20</span><br><span class="line">2018-09-17 18:07:47.369026+0800 demo11[30894:402677] ---eat----</span><br><span class="line">2018-09-17 18:07:47.369233+0800 demo11[30894:402677] ---crash----</span><br></pre></td></tr></table></figure></p>
<p>第三副图调用objc_msgSend方法直接绕过了这个预防机制。</p>
<p>使用<code>[persion setValue:@(4) forKey:@&quot;_count&quot;];</code>可以给存在的属性赋值<b>（无论其属性是否可读或隐藏）</b>，走的消息转发。</p>

          
        
      
    </div>
    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.msrily.com/2018/05/17/blog11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Richie Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Richie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/17/blog11/" itemprop="url">iOS App启动过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-17T13:57:39+08:00">
                2018-05-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Mach-O"><a href="#Mach-O" class="headerlink" title="Mach-O"></a>Mach-O</h2><p><img src="/images/299fcf31-8662-4634-af54-b6b0ca50ab2d.png" alt=""></p>
<ul>
<li>Header 头部，包含可以执行的CPU架构，比如x86,x86_64,arm7s,arm64</li>
<li>Load commands 加载命令，包含文件的组织架构和在虚拟内存中的布局方式</li>
<li>Data，数据，包含load commands中需要的各个段(segment)的数据，每一个Segment都得大小是Page的整数倍。<br>  1) <strong>TEXT 代码段，只读（通常使用于frameworks,bundles,shared libraries）<br>  2) </strong>DATA 数据段，读写<br>  3) <strong>OBJC OC动态语言支持相关的数据<br>  4) </strong>IMPORT 仅IA-32平台生成<br>  5) __LINKEDIT 动态链接器使用的元数据（符号、字符串、入口）</li>
</ul>
<h2 id="dyld"><a href="#dyld" class="headerlink" title="dyld"></a>dyld</h2><p>dyld的全称是<a href="https://developer.apple.com/library/archive/releasenotes/DeveloperTools/RN-dyld/" target="_blank" rel="noopener">dynamic loader</a>，它的作用是加载一个进程所需要的image，dyld是<a href="https://opensource.apple.com/source/dyld/dyld-421.2/" target="_blank" rel="noopener">开源的</a>。</p>
<h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><ol>
<li>加载dyld到App进程</li>
<li>加载动态库（包括所依赖的所有动态库）</li>
<li>Rebase </li>
<li>Bind </li>
<li>初始化Objective C Runtime </li>
<li>其它的初始化代码</li>
</ol>
<h3 id="加载动态库"><a href="#加载动态库" class="headerlink" title="加载动态库"></a>加载动态库</h3><p>dyld会首先读取mach-o文件的Header和load commands。<br>接着就知道了这个可执行文件依赖的动态库。例如加载动态库A到内存，接着检查A所依赖的动态库，就这样的递归加载，直到所有的动态库加载完毕。通常一个App所依赖的动态库在100-400个左右，其中大多数都是系统的动态库，它们会被缓存到dyld shared cache，这样读取的效率会很高。</p>
<p>查看mach-o文件所依赖的动态库，可以通过MachOView的图形化界面(展开Load Command就能看到)，也可以通过命令行otool。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otool -L demo</span><br></pre></td></tr></table></figure>
<h3 id="Rebase-amp-amp-Bind"><a href="#Rebase-amp-amp-Bind" class="headerlink" title="Rebase &amp;&amp; Bind"></a>Rebase &amp;&amp; Bind</h3><p>有两种主要的技术来保证应用的安全：ASLR和Code Sign。</p>
<p>ASLR的全称是Address space layout randomization，翻译过来就是“地址空间布局随机化”。App被启动的时候，程序会被映射到逻辑的地址空间，这个逻辑的地址空间有一个起始地址，而ASLR技术使得这个起始地址是随机的。如果是固定的，那么黑客很容易就可以由起始地址+偏移量找到函数的地址。</p>
<p>Code Sign相信大多数开发者都知晓，这里要提一点的是，在进行Code sign的时候，加密哈希不是针对于整个文件，而是针对于每一个Page的。这就保证了在dyld进行加载的时候，可以对每一个page进行独立的验证。</p>
<p>mach-o中有很多符号，有指向当前mach-o的，也有指向其他dylib的，比如printf。那么，在运行时，代码如何准确的找到printf的地址呢？</p>
<p>mach-o中采用了PIC技术，全称是Position Independ code。当你的程序要调用printf的时候，会先在__DATA段中建立一个指针指向printf，在通过这个指针实现间接调用。dyld这时候需要做一些fix-up工作，即帮助应用程序找到这些符号的实际地址。主要包括两部分:</p>
<ul>
<li>Rebase 修正内部(指向当前mach-o文件)的指针指向</li>
<li>Bind 修正外部指针指向</li>
</ul>
<p><img src="/images/20171023100523145.png" alt=""></p>
<p>之所以需要Rebase，是因为刚刚提到的ASLR使得地址随机化，导致起始地址不固定，另外由于Code Sign，导致不能直接修改Image。Rebase的时候只需要增加对应的偏移量即可。待Rebase的数据都存放在__LINKEDIT中。<br>可以通过MachOView查看：Dynamic Loader Info -&gt; Rebase Info</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun dyldinfo -<span class="built_in">bind</span> demo</span><br></pre></td></tr></table></figure>
<p>Rebase解决了内部的符号引用问题，而外部的符号引用则是由Bind解决。在解决Bind的时候，是根据字符串匹配的方式查找符号表，所以这个过程相对于Rebase来说是略慢的。</p>
<h3 id="初始化Objective-C-Runtime"><a href="#初始化Objective-C-Runtime" class="headerlink" title="初始化Objective C Runtime"></a>初始化Objective C Runtime</h3><p>Objective C是动态语言，所以在执行main函数之前，需要把类的信息注册到一个全局的Table中。同时，Objective C支持Category，在初始化的时候，也会把Category中的方法注册到对应的类中，同时会唯一Selector，这也是为什么当你的Cagegory实现了类中同名的方法后，类中的方法会被覆盖。</p>
<p>另外，由于iOS开发时基于Cocoa Touch的，所以绝大多数的类起始都是系统类，所以大多数的Runtime初始化起始在Rebase和Bind中已经完成。</p>
<h3 id="Initializers"><a href="#Initializers" class="headerlink" title="Initializers"></a>Initializers</h3><p>主要包括几部分：</p>
<ul>
<li>+load方法。</li>
<li>C／C++静态初始化对象和标记为<strong>attribute</strong>(constructor)的方法</li>
</ul>
<h4 id="注：-load方法已经被弃用了，如果你用Swift开发，你会发现根本无法去写这样一个方法，官方的建议是实用initialize。区别就是，load是在类装载的时候执行，而initialize是在类第一次收到message前调用。"><a href="#注：-load方法已经被弃用了，如果你用Swift开发，你会发现根本无法去写这样一个方法，官方的建议是实用initialize。区别就是，load是在类装载的时候执行，而initialize是在类第一次收到message前调用。" class="headerlink" title="注：+load方法已经被弃用了，如果你用Swift开发，你会发现根本无法去写这样一个方法，官方的建议是实用initialize。区别就是，load是在类装载的时候执行，而initialize是在类第一次收到message前调用。"></a>注：+load方法已经被弃用了，如果你用Swift开发，你会发现根本无法去写这样一个方法，官方的建议是实用initialize。区别就是，load是在类装载的时候执行，而initialize是在类第一次收到message前调用。</h4><h3 id="上文的讲解是dyld2的加载方式。而最新的是dyld3加载方式略有不同："><a href="#上文的讲解是dyld2的加载方式。而最新的是dyld3加载方式略有不同：" class="headerlink" title="上文的讲解是dyld2的加载方式。而最新的是dyld3加载方式略有不同："></a>上文的讲解是dyld2的加载方式。而最新的是dyld3加载方式略有不同：</h3><p><img src="/images/20171022203521690.png" alt=""></p>
<p>dyld2是纯粹的in-process，也就是在程序进程内执行的，也就意味着只有当应用程序被启动的时候，dyld2才能开始执行任务。</p>
<p>dyld3则是部分out-of-process，部分in-process。图中，虚线之上的部分是out-of-process的，在App下载安装和版本更新的时候会去执行，out-of-process会做如下事情：</p>
<ul>
<li>分析Mach-o Headers</li>
<li>分析依赖的动态库</li>
<li>查找需要Rebase &amp; Bind之类的符号</li>
<li>把上述结果写入缓存</li>
</ul>
<p>这样，在应用启动的时候，就可以直接从缓存中读取数据，加快加载速度。</p>
<p>启动时间在小于400ms是最佳的，因为从点击图标到显示Launch Screen，到Launch Screen消失这段时间是400ms。启动时间不可以大于20s，否则会被系统杀掉。</p>
<p>在Xcode中，可以通过设置环境变量来查看App的启动时间，DYLD_PRINT_STATISTICS和DYLD_PRINT_STATISTICS_DETAILS。</p>
<h3 id="优化启动时间"><a href="#优化启动时间" class="headerlink" title="优化启动时间"></a>优化启动时间</h3><h4 id="dylibs"><a href="#dylibs" class="headerlink" title="dylibs"></a>dylibs</h4><p>启动的第一步是加载动态库，加载系统的动态库使很快的，因为可以缓存，而加载内嵌的动态库速度较慢。所以，提高这一步的效率的关键是：减少动态库的数量。</p>
<p>合并动态库.比如公司内部由私有Pod建立了如下动态库：XXTableView, XXHUD, XXLabel，强烈建议合并成一个XXUIKit来提高加载速度。</p>
<h4 id="Rebase-amp-Bind-amp-Objective-C-Runtime"><a href="#Rebase-amp-Bind-amp-Objective-C-Runtime" class="headerlink" title="Rebase &amp; Bind &amp; Objective C Runtime"></a>Rebase &amp; Bind &amp; Objective C Runtime</h4><p>Rebase和Bind都是为了解决指针引用的问题。对于Objective C开发来说，主要的时间消耗在Class/Method的符号加载上，所以常见的优化方案是：</p>
<ul>
<li>减少__DATA段中的指针数量。</li>
<li>合并Category和功能类似的类。比如：UIView+Frame,UIView+AutoLayout…合并为一个删除无用的方法和类。</li>
<li>多用Swift Structs，因为Swfit Structs是静态分发的。</li>
</ul>
<h4 id="Initializers-1"><a href="#Initializers-1" class="headerlink" title="Initializers"></a>Initializers</h4><p>通常，我们会在+load方法中进行method-swizzling。</p>
<ul>
<li>用initialize替代load。不少同学喜欢用method-swizzling来实现AOP去做日志统计等内容，强烈建议改为在initialize进行初始化。</li>
<li>减少<strong>atribute</strong>((constructor))的使用，而是在第一次访问的时候才用dispatch_once等方式初始化。</li>
<li>不要创建线程</li>
<li>使用Swfit重写代码。</li>
</ul>
<p>转自：<a href="https://blog.csdn.net/Hello_Hwc/article/details/78317863?locationNum=9&amp;fps=1" target="_blank" rel="noopener">深入理解iOS App的启动过程</a></p>

          
        
      
    </div>
    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.msrily.com/2018/05/09/blog10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Richie Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Richie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/09/blog10/" itemprop="url">iOS SnapKit源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-09T15:50:02+08:00">
                2018-05-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>iOS布局从Frame到Autosizing，再到Autolayout。Storyboard上使用Autolayout对于层级不深的页面来说比较方便，大大提升了开发速度，但App体积也会增加不少，用代码写Autolayout就不是那么方便了。如</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// view1已经使用Autolayout布好局了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> view0 = <span class="type">UIView</span>()</span><br><span class="line">view0.backgroundColor = <span class="type">UIColor</span>.gray</span><br><span class="line">view0.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"><span class="keyword">self</span>.view.addSubview(view0)</span><br><span class="line"><span class="keyword">let</span> leftConstraint = <span class="type">NSLayoutConstraint</span>(item: view0, attribute: <span class="type">NSLayoutAttribute</span>.<span class="keyword">left</span>, relatedBy: <span class="type">NSLayoutRelation</span>.<span class="built_in">equal</span>, toItem: view1, attribute: <span class="type">NSLayoutAttribute</span>.<span class="keyword">left</span>, multiplier: <span class="number">1</span>, constant: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">let</span> topConstraint = <span class="type">NSLayoutConstraint</span>(item: view0, attribute: <span class="type">NSLayoutAttribute</span>.top, relatedBy: <span class="type">NSLayoutRelation</span>.<span class="built_in">equal</span>, toItem: <span class="keyword">self</span>.view, attribute: <span class="type">NSLayoutAttribute</span>.top, multiplier: <span class="number">1</span>, constant: <span class="number">20</span>)</span><br><span class="line"><span class="keyword">let</span> widthConstraint = <span class="type">NSLayoutConstraint</span>(item: view0, attribute: <span class="type">NSLayoutAttribute</span>.width, relatedBy: <span class="type">NSLayoutRelation</span>.<span class="built_in">equal</span>, toItem: <span class="keyword">self</span>.view, attribute: <span class="type">NSLayoutAttribute</span>.width, multiplier: <span class="number">0.5</span>, constant: <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> heightConstraint = <span class="type">NSLayoutConstraint</span>(item: view0, attribute: <span class="type">NSLayoutAttribute</span>.height, relatedBy: <span class="type">NSLayoutRelation</span>.<span class="built_in">equal</span>, toItem: view0, attribute: <span class="type">NSLayoutAttribute</span>.width, multiplier: <span class="number">1</span>, constant: <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> constraints = [leftConstraint, topConstraint, widthConstraint, heightConstraint]</span><br><span class="line"><span class="type">NSLayoutConstraint</span>.activate(constraints)</span><br></pre></td></tr></table></figure>
<p>布好一个控件就要写很长串，还怕写错，比较麻烦。<br><br>SnapKit是对Autolayout的封装，是Objective-C Masonry的同一个团体Swift版本。</p>
<p>使用Swift先进语法以及拟多态的方法极大地简化了代码写Autolayout约束，如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> view1 = <span class="type">UIView</span>()</span><br><span class="line">view1.backgroundColor = <span class="type">UIColor</span>.red</span><br><span class="line"><span class="keyword">self</span>.view.addSubview(view1)</span><br><span class="line">view1.snp.makeConstraints &#123; (make) <span class="keyword">in</span></span><br><span class="line">    make.<span class="keyword">left</span>.top.<span class="keyword">right</span>.bottom.equalTo(<span class="number">0</span>).offset(<span class="number">0</span>).multipliedBy(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>阅读起来很简单且使用方便</p>
<p>声明ConstraintConstantTarget(ConstraintOffsetTarget、ConstraintInsetTarget)，然后通过extension对一些已经存在的或者自定义的类型通过NSLayoutAttribute来转换成NSLayoutConstraint的constant，ConstraintMultiplierTarget通过extension来改变NSLayoutConstraint的multiplier,ConstraintPriorityTarget通过extension来改变NSLayoutConstraint的priority等。</p>
<p><img src="/images/1525858507.png" alt=""></p>
<p>这种编程方法值得学习。</p>
<p>声明ConstraintAttributes，将所有的属性都定义下来</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="keyword">none</span>: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">0</span>) &#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="keyword">left</span>: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">1</span>) &#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> top: <span class="type">ConstraintAttributes</span> &#123;  <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">2</span>) &#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="keyword">right</span>: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">4</span>) &#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> bottom: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">8</span>) &#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> leading: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">16</span>) &#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> trailing: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">32</span>) &#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> width: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">64</span>) &#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> height: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">128</span>) &#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> centerX: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">256</span>) &#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> centerY: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">512</span>) &#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> lastBaseline: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">1024</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">8.0</span>, <span class="type">OSX</span> <span class="number">10.11</span>, *)</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> firstBaseline: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">2048</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> leftMargin: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">4096</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> rightMargin: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">8192</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> topMargin: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">16384</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> bottomMargin: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">32768</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> leadingMargin: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">65536</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> trailingMargin: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">131072</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> centerXWithinMargins: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">262144</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> centerYWithinMargins: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">524288</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// aggregates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> edges: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">15</span>) &#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> size: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">192</span>) &#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> center: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">768</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> margins: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">61440</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> centerWithinMargins: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">786432</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到每个属性都是2的n次方<br><br>通过<figure class="highlight plain"><figcaption><span>layoutAttributes:[LayoutAttribute] ```来获取NSLayoutAttribute集合，这里用到Swift OptionSet类的union、formUnion、subtract和contains语法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ConstraintView的extensions中snp变量返回ConstraintViewDSL对象,ConstraintLayoutGuideDSL是它的子类，提供prepareConstraints、makeConstraints、remakeConstraints、updateConstraints、removeConstraints等方法。&lt;br/&gt;</span><br><span class="line">可以看到这些方法都是通过使用工厂类ConstraintMaker来管理约束的。</span><br><span class="line"></span><br><span class="line">```Swift</span><br><span class="line">    internal static func makeConstraints(item: LayoutConstraintItem, closure: (_ make: ConstraintMaker) -&gt; Void) &#123;</span><br><span class="line">        let maker = ConstraintMaker(item: item)</span><br><span class="line">        closure(maker)</span><br><span class="line">        var constraints: [Constraint] = []</span><br><span class="line">        for description in maker.descriptions &#123;</span><br><span class="line">            guard let constraint = description.constraint else &#123;</span><br><span class="line">                continue</span><br><span class="line">            &#125;</span><br><span class="line">            constraints.append(constraint)</span><br><span class="line">        &#125;</span><br><span class="line">        for constraint in constraints &#123;</span><br><span class="line">            constraint.activateIfNeeded(updatingExisting: false)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>ConstraintMaker的init方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">init</span>(item: <span class="type">LayoutConstraintItem</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.item = item</span><br><span class="line">    <span class="keyword">self</span>.item.prepare()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以left为例(同以上举例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```Swift</span><br><span class="line">    public var left: ConstraintMakerExtendable &#123;</span><br><span class="line">        return self.makeExtendableWithAttributes(.left)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    internal func makeExtendableWithAttributes(_ attributes: ConstraintAttributes) -&gt; ConstraintMakerExtendable &#123;</span><br><span class="line">        let description = ConstraintDescription(item: self.item, attributes: attributes)</span><br><span class="line">        self.descriptions.append(description)</span><br><span class="line">        return ConstraintMakerExtendable(description)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>ConstraintDescription是对NSLayoutConstraint的描述，生成Constraint对象，Constraint对象最终生成约束。</p>
<p>而之所以可以连着调用top、right、bottom得益于ConstraintMakerExtendable类：<figure class="highlight plain"><figcaption><span>self.makeExtendableWithAttributes(.left)```得到ConstraintMakerExtendable类，后面top</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">```Swift</span><br><span class="line">    //ConstraintMakerExtendable</span><br><span class="line">    public var top: ConstraintMakerExtendable &#123;</span><br><span class="line">        self.description.attributes += .top</span><br><span class="line">        return self</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //ConstraintAttributes</span><br><span class="line">    internal func +=(left: inout ConstraintAttributes, right: ConstraintAttributes) &#123;</span><br><span class="line">        left.formUnion(right)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //ConstraintMakerExtendable</span><br><span class="line">    public func equalTo(_ other: ConstraintRelatableTarget, _ file: String = #file, _ line: UInt = #line) -&gt; ConstraintMakerEditable &#123;</span><br><span class="line">        return self.relatedTo(other, relation: .equal, file: file, line: line)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    internal func relatedTo(_ other: ConstraintRelatableTarget, relation: ConstraintRelation, file: String, line: UInt) -&gt; ConstraintMakerEditable &#123;</span><br><span class="line">        let related: ConstraintItem</span><br><span class="line">        let constant: ConstraintConstantTarget</span><br><span class="line">        </span><br><span class="line">        if let other = other as? ConstraintItem &#123;</span><br><span class="line">            guard other.attributes == ConstraintAttributes.none ||</span><br><span class="line">                  other.attributes.layoutAttributes.count &lt;= 1 ||</span><br><span class="line">                  other.attributes.layoutAttributes == self.description.attributes.layoutAttributes ||</span><br><span class="line">                  other.attributes == .edges &amp;&amp; self.description.attributes == .margins ||</span><br><span class="line">                  other.attributes == .margins &amp;&amp; self.description.attributes == .edges else &#123;</span><br><span class="line">                fatalError(&quot;Cannot constraint to multiple non identical attributes. (\(file), \(line))&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            related = other</span><br><span class="line">            constant = 0.0</span><br><span class="line">        &#125; else if let other = other as? ConstraintView &#123;</span><br><span class="line">            related = ConstraintItem(target: other, attributes: ConstraintAttributes.none)</span><br><span class="line">            constant = 0.0</span><br><span class="line">        &#125; else if let other = other as? ConstraintConstantTarget &#123;</span><br><span class="line">            related = ConstraintItem(target: nil, attributes: ConstraintAttributes.none)</span><br><span class="line">            constant = other</span><br><span class="line">        &#125; else if #available(iOS 9.0, OSX 10.11, *), let other = other as? ConstraintLayoutGuide &#123;</span><br><span class="line">            related = ConstraintItem(target: other, attributes: ConstraintAttributes.none)</span><br><span class="line">            constant = 0.0</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            fatalError(&quot;Invalid constraint. (\(file), \(line))&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        let editable = ConstraintMakerEditable(self.description)</span><br><span class="line">        editable.description.sourceLocation = (file, line)</span><br><span class="line">        editable.description.relation = relation</span><br><span class="line">        editable.description.related = related</span><br><span class="line">        editable.description.constant = constant</span><br><span class="line">        return editable</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">item1.attribute1 = multiplier × item2.attribute2 + constant</span><br><span class="line"></span><br><span class="line"><span class="type">NSLayoutConstraint</span>(item: from, attribute: from属性, relatedBy: related关系, toItem: to, attribute: to属性, multiplier: multiplier, constant: constant)</span><br></pre></td></tr></table></figure>
<p>relatedTo这个方法生成related关系、“to”和“to”的属性和constant</p>
<p>接下来的offset和multipliedBy都是ConstraintMakerEditable类的实例方法</p>
<p><img src="/images/1525872713.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">```Swift</span><br><span class="line">    let layoutConstraint = LayoutConstraint(</span><br><span class="line">                item: layoutFrom,</span><br><span class="line">                attribute: layoutFromAttribute,</span><br><span class="line">                relatedBy: layoutRelation,</span><br><span class="line">                toItem: layoutTo,</span><br><span class="line">                attribute: layoutToAttribute,</span><br><span class="line">                multiplier: self.multiplier.constraintMultiplierTargetValue,</span><br><span class="line">                constant: layoutConstant</span><br><span class="line">            )</span><br></pre></td></tr></table></figure>
<p>生成了NSLayoutConstraint对象了,在Constraint类的方法activateIfNeeded中我们也发现了<code>NSLayoutConstraint.activate(layoutConstraints)</code>方法了。</p>

          
        
      
    </div>
    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.msrily.com/2018/04/13/blog9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Richie Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Richie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/13/blog9/" itemprop="url">Today Extension和3D Touch</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-13T14:38:52+08:00">
                2018-04-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Today-Extension"><a href="#Today-Extension" class="headerlink" title="Today Extension"></a>Today Extension</h3><h5 id="1-点击文件，选择如下图"><a href="#1-点击文件，选择如下图" class="headerlink" title="1.点击文件，选择如下图"></a>1.点击文件，选择如下图<br></h5><p><img src="/images/1523602659.png" alt=""><br><br><br><img src="/images/1523603517.png" alt=""><br><br><br><img src="/images/1523603742.png" alt=""></p>
<h5 id="2-选择scheme为demo，run之后显示“hello-world”"><a href="#2-选择scheme为demo，run之后显示“hello-world”" class="headerlink" title="2.选择scheme为demo，run之后显示“hello world”"></a>2.选择scheme为demo，run之后显示“hello world”<br></h5><p>在MainInterface.storyboard里或在TodayViewController里的viewdidload方法里布局UI（跟app开发一样）<br></p>
<h5 id="3-当需要与主app共享数据时，需配置App-Group，具体如下图"><a href="#3-当需要与主app共享数据时，需配置App-Group，具体如下图" class="headerlink" title="3.当需要与主app共享数据时，需配置App Group，具体如下图"></a>3.当需要与主app共享数据时，需配置App Group，具体如下图<br></h5><p><img src="/images/1523604601.png" alt=""><br>注：App Group为空时，请点左下角的”+”<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let userDefault = UserDefaults(suiteName: &quot;group.shine&quot;)!</span><br></pre></td></tr></table></figure></p>
<p>使用userDefault来存储需要共享的数据<br></p>
<h5 id="4-当extension需要调用主app的方法时通过URL方式"><a href="#4-当extension需要调用主app的方法时通过URL方式" class="headerlink" title="4.当extension需要调用主app的方法时通过URL方式"></a>4.当extension需要调用主app的方法时通过URL方式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.extensionContext?.open(URL(string: &quot;shineDemo://todayExtension?index=0&quot;)!, completionHandler: &#123; (res) in</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>
<p>主App配置URL的scheme<br><br><img src="/images/1523605177.png" alt=""></p>
<h3 id="3D-Touch"><a href="#3D-Touch" class="headerlink" title="3D Touch"></a>3D Touch</h3><p>上代码（动态3D Touch方式）<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> filePath = <span class="type">Bundle</span>.main.url(forResource: <span class="string">"3dtouchdemo"</span>, withExtension: <span class="string">"json"</span>),</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">try</span>? <span class="type">Data</span>.<span class="keyword">init</span>(contentsOf: filePath),</span><br><span class="line">        <span class="keyword">let</span> json = (<span class="keyword">try</span>? <span class="type">JSONSerialization</span>.jsonObject(with: data, options: <span class="type">JSONSerialization</span>.<span class="type">ReadingOptions</span>.mutableContainers)) <span class="keyword">as</span>? [[<span class="type">String</span>: <span class="type">Any</span>]] <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> items = [<span class="type">UIApplicationShortcutItem</span>]()</span><br><span class="line"><span class="keyword">for</span> jsonItem <span class="keyword">in</span> json &#123;</span><br><span class="line">    <span class="keyword">let</span> icon = <span class="type">UIApplicationShortcutIcon</span>(type: shortcutIconWithType(jsonItem[<span class="string">"icon"</span>] <span class="keyword">as</span>! <span class="type">String</span>))</span><br><span class="line">    <span class="keyword">let</span> item = <span class="type">UIApplicationShortcutItem</span>(type: jsonItem[<span class="string">"icon"</span>] <span class="keyword">as</span>! <span class="type">String</span>, localizedTitle: jsonItem[<span class="string">"title"</span>] <span class="keyword">as</span>! <span class="type">String</span>, localizedSubtitle: (jsonItem[<span class="string">"subtitle"</span>] <span class="keyword">as</span>! <span class="type">String</span>), icon: icon, userInfo: jsonItem[<span class="string">"userInfo"</span>] <span class="keyword">as</span>? [<span class="type">AnyHashable</span> : <span class="type">Any</span>])</span><br><span class="line">    items.append(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">UIApplication</span>.shared.shortcutItems = items</span><br></pre></td></tr></table></figure></p>
<p>附：3dtouchdemo.json<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    <span class="attr">"icon"</span>: <span class="string">"add"</span>,</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"增加"</span>,</span><br><span class="line">    <span class="attr">"subtitle"</span>: <span class="string">"增加-add"</span>,</span><br><span class="line">    <span class="attr">"userInfo"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"add"</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;,&#123;</span><br><span class="line">     <span class="attr">"icon"</span>: <span class="string">"alarm"</span>,</span><br><span class="line">     <span class="attr">"title"</span>: <span class="string">"闹钟"</span>,</span><br><span class="line">     <span class="attr">"subtitle"</span>: <span class="string">"闹钟-alarm"</span>,</span><br><span class="line">     <span class="attr">"userInfo"</span>: &#123;</span><br><span class="line">         <span class="attr">"type"</span>: <span class="string">"alarm"</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;]</span><br></pre></td></tr></table></figure></p>
<p>在AppDelegate委托方法里实现点击后的事件处理，可以通过UIApplicationShortcutItem的type来判断不同的Item<br><br><img src="/images/1523605834.png" alt=""></p>

          
        
      
    </div>
    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.msrily.com/2018/03/27/blog8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Richie Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Richie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/27/blog8/" itemprop="url">iOS app进入后台毛玻璃效果</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-27T11:14:34+08:00">
                2018-03-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>直接上代码（Swift）</p>
<pre>
    func applicationDidBecomeActive(_ application: UIApplication) {
        if let visualEffectView = self.visualEffectView {
            UIView.animate(withDuration: 0.5, animations: {
                visualEffectView.alpha = 0
            }, completion: { (_) in
                visualEffectView.removeFromSuperview()
            })
        }
    }

    weak var visualEffectView: UIVisualEffectView?
    func applicationWillResignActive(_ application: UIApplication) {
        let blurEffect = UIBlurEffect(style: UIBlurEffectStyle.light)
        let visualEffectView = UIVisualEffectView(effect: blurEffect)
        visualEffectView.alpha = 0
        visualEffectView.frame = self.window?.frame ?? CGRect.zero
        self.window?.addSubview(visualEffectView)
        self.visualEffectView = visualEffectView
        UIView.animate(withDuration: 0.5) {
            visualEffectView.alpha = 1
        }
    }
</pre>
          
        
      
    </div>
    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.msrily.com/2018/03/27/blog7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Richie Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Richie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/27/blog7/" itemprop="url">MySQL创建数据库与创建用户以及授权</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-27T11:12:00+08:00">
                2018-03-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>create schema [数据库名称] default character set utf8 collate utf8_general_ci;–创建数据库<br><br>　　采用create schema和create database创建数据库的效果一样。</li>
<li>create user ‘[用户名称]‘@’%’ identified by ‘[用户密码]’;–创建用户<br><br>　　密码8位以上，包括：大写字母、小写字母、数字、特殊字符<br><br>　　%：匹配所有主机，该地方还可以设置成‘localhost’，代表只能本地访问，例如root账户默认为‘localhost‘</li>
<li>grant select,insert,update,delete,create on [数据库名称].<em> to [用户名称];–用户授权数据库<br>
　　</em>代表整个数据库</li>
<li>flush  privileges ;–立即启用修改</li>
<li>revoke all on <em>.</em> from tester;–取消用户所有数据库（表）的所有权限</li>
<li>delete from mysql.user where user=’tester’;–删除用户</li>
<li>drop database [schema名称|数据库名称];–删除数据库</li>
</ol>

          
        
      
    </div>
    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.msrily.com/2018/03/27/blog6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Richie Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Richie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/27/blog6/" itemprop="url">macOS使用OpenSSL生成 RSA公钥与私钥</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-27T11:08:54+08:00">
                2018-03-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>macOS自带openssl环境，不用安装，直接使用openssl就可以<br><br><br>打开终端，进入到即将生成密钥文件的目录下，然后输入命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">openssl</span><br><span class="line">genrsa -out rsa_private_key.pem <span class="comment">#2048生成私钥</span></span><br><span class="line">pkcs8 -topk8 -inform PEM -<span class="keyword">in</span> rsa_private_key.pem -outform PEM -nocrypt -out rsa_private_key_pkcs8.pem <span class="comment">#将私钥转换成PKCS8格式</span></span><br><span class="line">rsa -<span class="keyword">in</span> rsa_private_key.pem -pubout -out rsa_public_key.pem <span class="comment">#生成公钥</span></span><br><span class="line"><span class="built_in">exit</span> <span class="comment">#退出</span></span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Richie Zhang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Richie Zhang</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
